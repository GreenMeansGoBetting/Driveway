<!-- /stream.html  (single-file OBS overlay page)
     1080p, full-width bottom bar, Side A left-aligned, Side B right-aligned,
     subtle divider, white-on-dark, and a brief highlight pulse on any player update.

     ✅ Uses window.SUPABASE_URL / window.SUPABASE_ANON_KEY if present.
     ✅ Falls back to URL params ?supabaseUrl=...&supabaseKey=... (optional)

     EXPECTED (editable) DB assumptions:
       - stream_state table with a single row id='main' and column active_game_id
       - games table has: id, side_a_score, side_b_score (or scores embedded)
       - players table has: game_id, name, side ("Side A"/"Side B"), stat_line (already formatted like your app)
     If your column names differ, edit the CONFIG section below.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Driveway Stream Overlay</title>
  <style>
    html, body { margin:0; padding:0; background: transparent; }
    body { overflow:hidden; }

    /* Fixed OBS canvas */
    #overlay {
      width: 1920px;
      height: 1080px;
      position: relative;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
    }

    /* Bottom bar */
    #bottomBar{
      position:absolute; left:0; right:0; bottom:0;
      height:190px;
      display:flex;
      gap:18px;
      padding:18px 22px;
      box-sizing:border-box;
      background: rgba(20, 20, 22, 0.82);
      backdrop-filter: blur(6px);
    }

    /* Players area */
    #playersArea{
      flex: 1;
      display:flex;
      align-items: stretch;
      min-width:0;
    }

    .sideCol{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-width:0;
    }

    /* Divider between Side A / Side B */
    .teamDivider{
      width:2px;
      margin: 0 18px;
      border-radius:2px;
      background: linear-gradient(
        to bottom,
        rgba(255,255,255,0.05),
        rgba(255,255,255,0.25),
        rgba(255,255,255,0.05)
      );
    }

    /* Player cards */
    .playerCard{
      border-radius:14px;
      padding:10px 12px;
      background: rgba(255,255,255,0.08);
      box-shadow: 0 6px 16px rgba(0,0,0,0.18);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:6px;
    }

    .playerName{
      font-weight: 800;
      font-size: 22px;
      letter-spacing: 0.3px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      color:#fff;
    }

    .playerLine{
      font-size: 18px;
      color: rgba(255,255,255,0.92);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-variant-numeric: tabular-nums;
    }

    /* Side alignment (broadcast style) */
    .sideA { text-align:left; }
    .sideB { text-align:right; }
    .sideA .playerCard { align-items:flex-start; }
    .sideB .playerCard { align-items:flex-end; }

    /* Score area */
    #scoreArea{
      width:360px;
      border-radius:16px;
      padding:12px 14px;
      box-sizing:border-box;
      background: rgba(10,10,12,0.9);
      box-shadow: 0 10px 22px rgba(0,0,0,0.25);
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:10px;
    }

    .scoreRow{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
    }

    .teamLabel{
      font-weight:800;
      font-size:20px;
      opacity:0.95;
    }

    .teamScore{
      font-weight:900;
      font-size:56px;
      font-variant-numeric: tabular-nums;
      color:#fff;
    }

    .ruleLine{
      margin-top:2px;
      font-weight:800;
      font-size:15px;
      letter-spacing:0.6px;
      opacity:0.8;
      text-align:center;
    }

    /* Flash highlight pulse on update */
    .flash{
      animation: pulseHighlight 0.9s ease-out 1;
    }
    @keyframes pulseHighlight{
      0%   { background: rgba(255,255,255,0.18); transform: translateY(-1px); }
      40%  { background: rgba(255,255,255,0.12); box-shadow: 0 0 24px rgba(255,255,255,0.18); }
      100% { background: rgba(255,255,255,0.08); transform: translateY(0px); }
    }

    /* Small helper message if not configured */
    #status{
      position:absolute;
      left:18px; top:18px;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,0.55);
      font-size:16px;
      max-width: 820px;
      line-height: 1.25;
      display:none;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="status"></div>

    <div id="bottomBar">
      <div id="playersArea">
        <div class="sideCol sideA" id="sideACol"></div>
        <div class="teamDivider"></div>
        <div class="sideCol sideB" id="sideBCol"></div>
      </div>

      <div id="scoreArea">
        <div class="scoreRow">
          <div class="teamLabel">Side A</div>
          <div class="teamScore" id="sideAScore">0</div>
        </div>
        <div class="scoreRow">
          <div class="teamLabel">Side B</div>
          <div class="teamScore" id="sideBScore">0</div>
        </div>
        <div class="ruleLine">TO 40 • WIN BY 3</div>
      </div>
    </div>
  </div>

  <!-- Inline config (you can keep this, or move to config.js if you want) -->
  <script>
    window.SUPABASE_URL = "https://mpvzicatxjzoaxtlieyw.supabase.co";
    window.SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1wdnppY2F0eGp6b2F4dGxpZXl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIxMzEyOTcsImV4cCI6MjA4NzcwNzI5N30.QmpgY48F1_5OBeW0J8HQ_TDWfFy_rds-vnlDRtpFEqk";
  </script>

  <!-- Supabase JS (UMD) - LOAD ONCE -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <script>
    /********************
     * CONFIG (EDIT IF NEEDED)
     ********************/
    const CONFIG = {
      STREAM_STATE_TABLE: "stream_state",
      STREAM_STATE_PK_COL: "id",
      STREAM_STATE_PK_VAL: "main",
      STREAM_STATE_ACTIVE_GAME_COL: "active_game_id",

      GAMES_TABLE: "games",
      GAME_ID_COL: "game_id",              // <-- IMPORTANT: your app uses game_id, not id
      GAME_SIDE_A_SCORE_COL: "final_score_a", // <-- if you want live score, you need an actual column or compute from events
      GAME_SIDE_B_SCORE_COL: "final_score_b",

      PLAYERS_TABLE: "players",
      PLAYER_GAME_ID_COL: "game_id",
      PLAYER_ID_COL: "player_id",
      PLAYER_NAME_COL: "name",
      PLAYER_SIDE_COL: "side",              // expect "Side A" / "Side B"
      PLAYER_STATLINE_COL: "stat_line"      // already formatted string (like your app)
    };

    /********************
     * DOM
     ********************/
    const statusEl = document.getElementById("status");
    const sideACol = document.getElementById("sideACol");
    const sideBCol = document.getElementById("sideBCol");
    const sideAScoreEl = document.getElementById("sideAScore");
    const sideBScoreEl = document.getElementById("sideBScore");

    function setStatus(msg){
      statusEl.textContent = msg;
      statusEl.style.display = msg ? "block" : "none";
    }

    /********************
     * HELPERS
     ********************/
    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function cardHTML(player){
      const id = player[CONFIG.PLAYER_ID_COL];
      const name = player[CONFIG.PLAYER_NAME_COL] ?? "—";
      const line = player[CONFIG.PLAYER_STATLINE_COL] ?? "";
      return `
        <div class="playerCard" id="player-${escapeHtml(id)}">
          <div class="playerName">${escapeHtml(name)}</div>
          <div class="playerLine">${escapeHtml(line)}</div>
        </div>
      `;
    }

    function flashPlayer(playerId){
      const el = document.getElementById(`player-${playerId}`);
      if (!el) return;
      el.classList.remove("flash");
      void el.offsetWidth;
      el.classList.add("flash");
    }

    /********************
     * SUPABASE INIT (NO NAME COLLISION)
     ********************/
    function getParam(name){
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }

    const SUPABASE_URL =
      window.SUPABASE_URL ||
      getParam("supabaseUrl") ||
      "";

    const SUPABASE_ANON_KEY =
      window.SUPABASE_ANON_KEY ||
      getParam("supabaseKey") ||
      "";

    if (!SUPABASE_URL || !SUPABASE_ANON_KEY){
      setStatus("Overlay not configured. Set window.SUPABASE_URL and window.SUPABASE_ANON_KEY, or load with ?supabaseUrl=...&supabaseKey=...");
    }

    // IMPORTANT: do NOT name this `supabase`
    const sbClient = (SUPABASE_URL && SUPABASE_ANON_KEY)
      ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      : null;

    /********************
     * RENDER + HIGHLIGHT
     ********************/
    let lastStatByPlayerId = new Map();

    function render(gameRow, players){
      const a = gameRow?.[CONFIG.GAME_SIDE_A_SCORE_COL] ?? 0;
      const b = gameRow?.[CONFIG.GAME_SIDE_B_SCORE_COL] ?? 0;
      sideAScoreEl.textContent = a;
      sideBScoreEl.textContent = b;

      const sideA = (players || []).filter(p => (p[CONFIG.PLAYER_SIDE_COL] ?? "").toLowerCase() === "side a");
      const sideB = (players || []).filter(p => (p[CONFIG.PLAYER_SIDE_COL] ?? "").toLowerCase() === "side b");

      sideACol.innerHTML = sideA.map(cardHTML).join("");
      sideBCol.innerHTML = sideB.map(cardHTML).join("");

      for (const p of (players || [])){
        const pid = p[CONFIG.PLAYER_ID_COL];
        const newLine = p[CONFIG.PLAYER_STATLINE_COL] ?? "";
        const oldLine = lastStatByPlayerId.get(pid);
        if (oldLine !== undefined && oldLine !== newLine){
          flashPlayer(pid);
        }
        lastStatByPlayerId.set(pid, newLine);
      }
    }

    /********************
     * DATA FETCH
     ********************/
    let activeGameId = null;
    let liveGameChannel = null;
    let refreshTimer = null;

    function throttleRefresh(ms=250){
      if (refreshTimer) return;
      refreshTimer = setTimeout(async () => {
        refreshTimer = null;
        if (activeGameId) await loadGame(activeGameId);
      }, ms);
    }

    async function loadActiveGameId(){
      const { data, error } = await sbClient
        .from(CONFIG.STREAM_STATE_TABLE)
        .select(`${CONFIG.STREAM_STATE_ACTIVE_GAME_COL}`)
        .eq(CONFIG.STREAM_STATE_PK_COL, CONFIG.STREAM_STATE_PK_VAL)
        .single();

      if (error){
        setStatus("Could not read stream_state. Check table/columns + RLS policy.");
        console.error(error);
        return null;
      }
      setStatus("");
      return data?.[CONFIG.STREAM_STATE_ACTIVE_GAME_COL] ?? null;
    }

    async function loadGame(gameId){
      // Fetch game
      const { data: gameRow, error: gameErr } = await sbClient
        .from(CONFIG.GAMES_TABLE)
        .select("*")
        .eq(CONFIG.GAME_ID_COL, gameId)
        .single();

      if (gameErr){
        setStatus("Could not load active game row. Check games table/columns + RLS policy.");
        console.error(gameErr);
        return;
      }

      // Fetch players (ONLY works if you actually store per-game player rows in `players`)
      const { data: players, error: playersErr } = await sbClient
        .from(CONFIG.PLAYERS_TABLE)
        .select("*")
        .eq(CONFIG.PLAYER_GAME_ID_COL, gameId);

      if (playersErr){
        setStatus("Could not load players. Check players table/columns + RLS policy.");
        console.error(playersErr);
        return;
      }

      render(gameRow, players || []);
    }

    /********************
     * REALTIME SUBSCRIPTIONS
     ********************/
    async function subscribeStreamState(){
      sbClient
        .channel("stream_state_changes")
        .on(
          "postgres_changes",
          {
            event: "*",
            schema: "public",
            table: CONFIG.STREAM_STATE_TABLE,
            filter: `${CONFIG.STREAM_STATE_PK_COL}=eq.${CONFIG.STREAM_STATE_PK_VAL}`
          },
          async (payload) => {
            const next = payload.new?.[CONFIG.STREAM_STATE_ACTIVE_GAME_COL] ?? null;
            if (next !== activeGameId){
              if (!next){
                activeGameId = null;
                sideAScoreEl.textContent = "0";
                sideBScoreEl.textContent = "0";
                sideACol.innerHTML = "";
                sideBCol.innerHTML = "";
                setStatus("No active game set yet.");
                return;
              }
              await switchActiveGame(next);
            }
          }
        )
        .subscribe();
    }

    async function subscribeLiveGame(gameId){
      if (liveGameChannel){
        try { await sbClient.removeChannel(liveGameChannel); } catch(e){}
        liveGameChannel = null;
      }

      liveGameChannel = sbClient
        .channel(`live_game_${gameId}`)
        .on(
          "postgres_changes",
          {
            event: "*",
            schema: "public",
            table: CONFIG.GAMES_TABLE,
            filter: `${CONFIG.GAME_ID_COL}=eq.${gameId}`
          },
          () => throttleRefresh(120)
        )
        .on(
          "postgres_changes",
          {
            event: "*",
            schema: "public",
            table: CONFIG.PLAYERS_TABLE,
            filter: `${CONFIG.PLAYER_GAME_ID_COL}=eq.${gameId}`
          },
          () => throttleRefresh(120)
        )
        .subscribe();
    }

    async function switchActiveGame(gameId){
      activeGameId = gameId;
      lastStatByPlayerId = new Map();
      await subscribeLiveGame(gameId);
      await loadGame(gameId);
    }

    /********************
     * BOOT
     ********************/
    (async function boot(){
      if (!sbClient) return;

      await subscribeStreamState();

      const gid = await loadActiveGameId();
      if (!gid){
        setStatus("No active game set yet. Set stream_state.active_game_id to a game id.");
        return;
      }
      await switchActiveGame(gid);
    })();
  </script>
</body>
</html>
