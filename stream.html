<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Driveway Stream Overlay</title>
  <style>
    html, body { margin:0; padding:0; background: transparent; }
    body { overflow:hidden; }

    #overlay {
      width: 1920px;
      height: 1080px;
      position: relative;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
    }

    #bottomBar{
      position:absolute; left:0; right:0; bottom:0;
      height:190px;
      display:flex;
      gap:18px;
      padding:18px 22px;
      box-sizing:border-box;
      background: rgba(20, 20, 22, 0.82);
      backdrop-filter: blur(6px);
    }

    #playersArea{
      flex: 1;
      display:flex;
      align-items: stretch;
      min-width:0;
    }

    .sideCol{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-width:0;
    }

    .teamDivider{
      width:2px;
      margin: 0 18px;
      border-radius:2px;
      background: linear-gradient(
        to bottom,
        rgba(255,255,255,0.05),
        rgba(255,255,255,0.25),
        rgba(255,255,255,0.05)
      );
    }

    .playerCard{
      border-radius:14px;
      padding:10px 12px;
      background: rgba(255,255,255,0.08);
      box-shadow: 0 6px 16px rgba(0,0,0,0.18);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:6px;
    }

    .playerName{
      font-weight: 800;
      font-size: 22px;
      letter-spacing: 0.3px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      color:#fff;
    }

    .playerLine{
      font-size: 18px;
      color: rgba(255,255,255,0.92);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-variant-numeric: tabular-nums;
    }

    .sideA { text-align:left; }
    .sideB { text-align:right; }
    .sideA .playerCard { align-items:flex-start; }
    .sideB .playerCard { align-items:flex-end; }

    #scoreArea{
      width:360px;
      border-radius:16px;
      padding:12px 14px;
      box-sizing:border-box;
      background: rgba(10,10,12,0.9);
      box-shadow: 0 10px 22px rgba(0,0,0,0.25);
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:10px;
    }

    .scoreRow{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
    }

    .teamLabel{
      font-weight:800;
      font-size:20px;
      opacity:0.95;
    }

    .teamScore{
      font-weight:900;
      font-size:56px;
      font-variant-numeric: tabular-nums;
      color:#fff;
    }

    .ruleLine{
      margin-top:2px;
      font-weight:800;
      font-size:15px;
      letter-spacing:0.6px;
      opacity:0.8;
      text-align:center;
    }

    .flash{
      animation: pulseHighlight 0.9s ease-out 1;
    }
    @keyframes pulseHighlight{
      0%   { background: rgba(255,255,255,0.18); transform: translateY(-1px); }
      40%  { background: rgba(255,255,255,0.12); box-shadow: 0 0 24px rgba(255,255,255,0.18); }
      100% { background: rgba(255,255,255,0.08); transform: translateY(0px); }
    }

    #status{
      position:absolute;
      left:18px; top:18px;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,0.55);
      font-size:16px;
      max-width: 920px;
      line-height: 1.25;
      display:none;
      z-index: 9999;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="status"></div>

    <div id="bottomBar">
      <div id="playersArea">
        <div class="sideCol sideA" id="sideACol"></div>
        <div class="teamDivider"></div>
        <div class="sideCol sideB" id="sideBCol"></div>
      </div>

      <div id="scoreArea">
        <div class="scoreRow">
          <div class="teamLabel">Side A</div>
          <div class="teamScore" id="sideAScore">0</div>
        </div>
        <div class="scoreRow">
          <div class="teamLabel">Side B</div>
          <div class="teamScore" id="sideBScore">0</div>
        </div>
        <div class="ruleLine">TO 40 • WIN BY 3</div>
      </div>
    </div>
  </div>

  <!-- You can keep these here OR load config.js that sets them -->
  <script>
    window.SUPABASE_URL = "https://mpvzicatxjzoaxtlieyw.supabase.co";
    window.SUPABASE_ANON_KEY = "PASTE_YOUR_ANON_KEY_HERE_IF_YOU_WANT";
    // OPTIONAL (recommended for multi-user safety):
    // window.OVERLAY_OWNER_ID = "YOUR_AUTH_UID";
  </script>

  <!-- Load Supabase ONCE -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>

  <script>
    /********************
     * CONFIG (matches YOUR schema)
     ********************/
    const CONFIG = {
      GAMES_TABLE: "games",
      EVENTS_TABLE: "events",
      PLAYERS_TABLE: "players",
      STREAM_STATE_TABLE: "stream_state",

      STREAM_STATE_PK_COL: "id",
      STREAM_STATE_PK_VAL: "main",
      STREAM_STATE_ACTIVE_GAME_COL: "active_game_id",
      STREAM_STATE_OWNER_COL: "owner_id",

      GAMES_ID_COL: "game_id",
      GAMES_SIDEA_COL: "sidea_player_ids",
      GAMES_SIDEB_COL: "sideb_player_ids",
      GAMES_OWNER_COL: "owner_id",

      EVENTS_GAME_COL: "game_id",
      EVENTS_PLAYER_COL: "player_id",
      EVENTS_TYPE_COL: "stat_type",
      EVENTS_DELTA_COL: "delta",
      EVENTS_TS_COL: "timestamp",
      EVENTS_OWNER_COL: "owner_id",

      PLAYERS_ID_COL: "player_id",
      PLAYERS_NAME_COL: "name",
      PLAYERS_OWNER_COL: "owner_id",
    };

    /********************
     * DOM
     ********************/
    const statusEl = document.getElementById("status");
    const sideACol = document.getElementById("sideACol");
    const sideBCol = document.getElementById("sideBCol");
    const sideAScoreEl = document.getElementById("sideAScore");
    const sideBScoreEl = document.getElementById("sideBScore");

    function setStatus(msg){
      statusEl.textContent = msg || "";
      statusEl.style.display = msg ? "block" : "none";
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function getParam(name){
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }

    /********************
     * SUPABASE INIT (no naming collision)
     ********************/
    const SUPABASE_URL = window.SUPABASE_URL || getParam("supabaseUrl") || "";
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || getParam("supabaseKey") || "";

    // Owner scoping (optional but recommended)
    const OVERLAY_OWNER_ID =
      window.OVERLAY_OWNER_ID ||
      getParam("ownerId") ||
      "";

    if (!SUPABASE_URL || !SUPABASE_ANON_KEY){
      setStatus("Overlay not configured. Set window.SUPABASE_URL and window.SUPABASE_ANON_KEY (or use ?supabaseUrl=...&supabaseKey=...).");
    }

    // IMPORTANT: do NOT call this variable `supabase`
    const sbClient = (SUPABASE_URL && SUPABASE_ANON_KEY)
      ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      : null;

    /********************
     * STAT COMPUTATION (matches your app)
     ********************/
    const STAT_TYPES = ["2PM","2PMISS","3PM","3PMISS","AST","OREB","DREB","BLK","STL"];

    function computeFromEvents(gameRow, events){
      const sideA = gameRow?.[CONFIG.GAMES_SIDEA_COL] || [];
      const sideB = gameRow?.[CONFIG.GAMES_SIDEB_COL] || [];

      const lines = new Map();
      for (const pid of [...sideA, ...sideB]){
        const o = {};
        for (const s of STAT_TYPES) o[s] = 0;
        lines.set(String(pid), o);
      }

      for (const ev of (events || [])){
        const pid = String(ev[CONFIG.EVENTS_PLAYER_COL]);
        const stat = ev[CONFIG.EVENTS_TYPE_COL];
        const delta = Number(ev[CONFIG.EVENTS_DELTA_COL] ?? 1);
        const line = lines.get(pid);
        if (!line) continue;
        line[stat] = (line[stat] || 0) + delta;
      }

      const derived = (pid)=>{
        const l = lines.get(String(pid)) || {};
        const twoA = (l["2PM"]||0) + (l["2PMISS"]||0);
        const threeA = (l["3PM"]||0) + (l["3PMISS"]||0);
        const pts = (l["2PM"]||0)*2 + (l["3PM"]||0)*3;
        const reb = (l["OREB"]||0) + (l["DREB"]||0);
        return { twoA, threeA, pts, reb };
      };

      const scoreA = sideA.reduce((s,p)=> s + derived(p).pts, 0);
      const scoreB = sideB.reduce((s,p)=> s + derived(p).pts, 0);

      return { sideA, sideB, lines, derived, scoreA, scoreB };
    }

    function formatStatLine(pid, box){
      const line = box.lines.get(String(pid)) || {};
      const d = box.derived(pid);
      const pts = d.pts;
      const twoM = line["2PM"] || 0;
      const threeM = line["3PM"] || 0;
      const oreb = line["OREB"] || 0;
      const dreb = line["DREB"] || 0;
      const reb = (oreb + dreb);
      const ast = line["AST"] || 0;
      const stl = line["STL"] || 0;
      const blk = line["BLK"] || 0;

      return `PTS ${pts} | 2s ${twoM}-${d.twoA} | 3s ${threeM}-${d.threeA} | REB ${reb} (O${oreb}/D${dreb}) | AST ${ast} | STL ${stl} | BLK ${blk}`;
    }

    /********************
     * RENDER
     ********************/
    let lastLineByPid = new Map();

    function flashPlayer(pid){
      const el = document.getElementById(`player-${pid}`);
      if (!el) return;
      el.classList.remove("flash");
      void el.offsetWidth;
      el.classList.add("flash");
    }

    function playerCardHTML(pid, name, line){
      return `
        <div class="playerCard" id="player-${escapeHtml(pid)}">
          <div class="playerName">${escapeHtml(name)}</div>
          <div class="playerLine">${escapeHtml(line)}</div>
        </div>
      `;
    }

    function renderOverlay(box, nameById){
      sideAScoreEl.textContent = String(box.scoreA ?? 0);
      sideBScoreEl.textContent = String(box.scoreB ?? 0);

      const sideAHtml = box.sideA.map(pid => {
        const id = String(pid);
        const nm = nameById.get(id) || "—";
        const ln = formatStatLine(id, box);
        return playerCardHTML(id, nm, ln);
      }).join("");

      const sideBHtml = box.sideB.map(pid => {
        const id = String(pid);
        const nm = nameById.get(id) || "—";
        const ln = formatStatLine(id, box);
        return playerCardHTML(id, nm, ln);
      }).join("");

      sideACol.innerHTML = sideAHtml;
      sideBCol.innerHTML = sideBHtml;

      // highlight changed stat lines
      for (const pid of [...box.sideA, ...box.sideB]){
        const id = String(pid);
        const ln = formatStatLine(id, box);
        const prev = lastLineByPid.get(id);
        if (prev !== undefined && prev !== ln) flashPlayer(id);
        lastLineByPid.set(id, ln);
      }
    }

    /********************
     * DATA LOADERS
     ********************/
    let activeGameId = null;
    let chanStream = null;
    let chanLive = null;

    function ownerEq(q, col){
      return OVERLAY_OWNER_ID ? q.eq(col, OVERLAY_OWNER_ID) : q;
    }

    async function loadActiveGameId(){
      let q = sbClient
        .from(CONFIG.STREAM_STATE_TABLE)
        .select(`${CONFIG.STREAM_STATE_ACTIVE_GAME_COL}`)
        .eq(CONFIG.STREAM_STATE_PK_COL, CONFIG.STREAM_STATE_PK_VAL);

      q = ownerEq(q, CONFIG.STREAM_STATE_OWNER_COL);

      const { data, error } = await q.single();
      if (error){
        setStatus("Could not read stream_state (RLS?). If you use RLS, pass ?ownerId=YOUR_UID or set window.OVERLAY_OWNER_ID.");
        console.error(error);
        return null;
      }
      setStatus("");
      return data?.[CONFIG.STREAM_STATE_ACTIVE_GAME_COL] || null;
    }

    async function loadGameAndRender(gameId){
      if (!gameId) return;

      // GAME
      let gq = sbClient
        .from(CONFIG.GAMES_TABLE)
        .select("*")
        .eq(CONFIG.GAMES_ID_COL, gameId);

      gq = ownerEq(gq, CONFIG.GAMES_OWNER_COL);

      const { data: gameRow, error: gameErr } = await gq.single();
      if (gameErr){
        setStatus("Could not load games row for active_game_id (RLS? wrong id?).");
        console.error(gameErr);
        return;
      }

      const sideA = gameRow?.[CONFIG.GAMES_SIDEA_COL] || [];
      const sideB = gameRow?.[CONFIG.GAMES_SIDEB_COL] || [];
      const allPids = [...sideA, ...sideB].map(String);

      // PLAYERS (names)
      let pq = sbClient
        .from(CONFIG.PLAYERS_TABLE)
        .select(`${CONFIG.PLAYERS_ID_COL}, ${CONFIG.PLAYERS_NAME_COL}`)
        .in(CONFIG.PLAYERS_ID_COL, allPids);

      pq = ownerEq(pq, CONFIG.PLAYERS_OWNER_COL);

      const { data: playerRows, error: pErr } = await pq;
      if (pErr){
        setStatus("Could not load players (RLS?).");
        console.error(pErr);
        return;
      }

      const nameById = new Map((playerRows || []).map(r => [String(r[CONFIG.PLAYERS_ID_COL]), r[CONFIG.PLAYERS_NAME_COL]]));

      // EVENTS (for live score + stats)
      let eq = sbClient
        .from(CONFIG.EVENTS_TABLE)
        .select("*")
        .eq(CONFIG.EVENTS_GAME_COL, gameId)
        .order(CONFIG.EVENTS_TS_COL, { ascending: true });

      eq = ownerEq(eq, CONFIG.EVENTS_OWNER_COL);

      const { data: events, error: eErr } = await eq;
      if (eErr){
        setStatus("Could not load events for the active game (RLS?).");
        console.error(eErr);
        return;
      }

      const box = computeFromEvents(gameRow, events || []);
      renderOverlay(box, nameById);
    }

    /********************
     * REALTIME
     ********************/
    let refreshTimer = null;
    function throttleRefresh(ms=120){
      if (refreshTimer) return;
      refreshTimer = setTimeout(async () => {
        refreshTimer = null;
        if (activeGameId) await loadGameAndRender(activeGameId);
      }, ms);
    }

    async function subscribeStreamState(){
      if (chanStream){
        try { await sbClient.removeChannel(chanStream); } catch(e){}
        chanStream = null;
      }

      const filterParts = [`${CONFIG.STREAM_STATE_PK_COL}=eq.${CONFIG.STREAM_STATE_PK_VAL}`];
      if (OVERLAY_OWNER_ID) filterParts.push(`${CONFIG.STREAM_STATE_OWNER_COL}=eq.${OVERLAY_OWNER_ID}`);
      const filter = filterParts.join(",");

      chanStream = sbClient
        .channel("overlay_stream_state")
        .on("postgres_changes",
          { event:"*", schema:"public", table: CONFIG.STREAM_STATE_TABLE, filter },
          async (payload) => {
            const next = payload.new?.[CONFIG.STREAM_STATE_ACTIVE_GAME_COL] || null;
            if (next !== activeGameId){
              await switchActiveGame(next);
            }
          }
        )
        .subscribe();
    }

    async function subscribeLive(gameId){
      if (chanLive){
        try { await sbClient.removeChannel(chanLive); } catch(e){}
        chanLive = null;
      }

      // events changes for this game
      const fEventsParts = [`${CONFIG.EVENTS_GAME_COL}=eq.${gameId}`];
      if (OVERLAY_OWNER_ID) fEventsParts.push(`${CONFIG.EVENTS_OWNER_COL}=eq.${OVERLAY_OWNER_ID}`);
      const fEvents = fEventsParts.join(",");

      // game changes (rosters etc)
      const fGameParts = [`${CONFIG.GAMES_ID_COL}=eq.${gameId}`];
      if (OVERLAY_OWNER_ID) fGameParts.push(`${CONFIG.GAMES_OWNER_COL}=eq.${OVERLAY_OWNER_ID}`);
      const fGame = fGameParts.join(",");

      chanLive = sbClient
        .channel(`overlay_live_${gameId}`)
        .on("postgres_changes",
          { event:"*", schema:"public", table: CONFIG.EVENTS_TABLE, filter: fEvents },
          () => throttleRefresh(90)
        )
        .on("postgres_changes",
          { event:"*", schema:"public", table: CONFIG.GAMES_TABLE, filter: fGame },
          () => throttleRefresh(120)
        )
        .subscribe();
    }

    async function switchActiveGame(gameId){
      activeGameId = gameId;
      lastLineByPid = new Map();

      if (!activeGameId){
        sideAScoreEl.textContent = "0";
        sideBScoreEl.textContent = "0";
        sideACol.innerHTML = "";
        sideBCol.innerHTML = "";
        setStatus("No active game set yet.");
        return;
      }

      setStatus("");
      await subscribeLive(activeGameId);
      await loadGameAndRender(activeGameId);
    }

    /********************
     * BOOT
     ********************/
    (async function boot(){
      if (!sbClient) return;

      await subscribeStreamState();

      const gid = await loadActiveGameId();
      if (!gid){
        setStatus("No active game set (stream_state.active_game_id is null). Start a game in the app.");
        return;
      }

      await switchActiveGame(gid);
    })();
  </script>
</body>
</html>
